---
title: mysql数据库索引解析
categories: [数据库,mysql]

toc: true
keywords: java
date: 2019-06-04 19:36:04
thumbnail: https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620153720.png
tags: [mysql,索引]
---
> 摘要
看了很多关于索引的博客，讲的大同小异。但是始终没有让我明白关于索引的一些概念，如B-Tree索引，Hash索引，唯一索引....或许有很多人和我一样，没搞清楚概念就开始研究B-Tree，B+Tree等结构，导致在面试的时候答非所问！
<!-- more -->

### 索引是什么?

索引是帮助MySQL高效获取数据的数据结构。

### 索引能干什么?

索引非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。 索引能够轻易将查询性能提高好几个数量级，总的来说就是可以明显的提高查询效率。

### 索引的分类?

1. 从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，

2. 从应用层次来分：普通索引，唯一索引，复合索引

3. 根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。

平时讲的索引类型一般是指在应用层次的划分。就像手机分类：安卓手机，IOS手机 与 华为手机，苹果手机，OPPO手机一样。

**普通索引****：**即一个索引只包含单个列，一个表可以有多个单列索引

**唯一索引：**索引列的值必须唯一，但允许有空值

**复合索引：**多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

**聚簇索引(聚集索引)：**并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。

**非聚簇索引：**不是聚簇索引，就是非聚簇索引

### 索引的底层实现

mysql默认存储引擎innodb只显式支持B-Tree( 从技术上来说是B+Tree)索引，对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。

不谈存储引擎，只讨论实现(抽象)

#### Hash索引

基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620153804.png)

#### B-Tree索引（MySQL使用B+Tree）

B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620153834.png)

B+Tree索引

是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620153924.png)

结合存储引擎来讨论（一般默认使用B+Tree）

案例：假设有一张学生表，id为主键

| id   | name    | birthday   |
| :--- | :------ | :--------- |
| 1    | Tom     | 1996-01-01 |
| 2    | Jann    | 1996-01-04 |
| 3    | Ray     | 1996-01-08 |
| 4    | Michael | 1996-01-10 |
| 5    | Jack    | 1996-01-13 |
| 6    | Steven  | 1996-01-23 |
| 7    | Lily    | 1996-01-25 |

**在MyISAM引擎中的实现**（二级索引也是这样实现的）

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620153946.png)

在InnoDB中的实现

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620154003.png)

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620154020.png)

### 为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？

B+tree：因为B树**不管叶子节点还是非叶子节点，都会保存数据**，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；

Hash：虽然可以快速定位，但是没有顺序，IO复杂度高。

二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。

红黑树：树的高度随着数据量增加而增加，IO代价高。

> 红黑树:
>
> 1. 每个节点或者是黑色，或者是红色。
> 2.  根节点是黑色。
> 3.  每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]
> 4.  如果一个节点是红色的，则它的子节点必须是黑色的。
> 5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

### 为什么官方建议使用自增长主键作为索引？

结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。

插入连续的数据：

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/b5d1b710ly4g3pc5ln9mmg20di04fjsq.gif)


插入非连续的数据

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/b5d1b710ly4g3pc6246isg20di04fjwr.gif)


### 简单总结下

1. MySQL使用B+Tree作为索引数据结构。 
2. B+Tree在新增数据时，会根据索引指定列的值对旧的B+Tree做调整。
3. 从物理存储结构上说，B-Tree和B+Tree都以页(4K)来划分节点的大小，但是由于B+Tree中中间节点不存储数据，因此B+Tree能够在同样大小的节点中，存储更多的key，提高查找效率。 
4. 影响MySQL查找性能的主要还是磁盘IO次数，大部分是磁头移动到指定磁道的时间花费。
5. MyISAM存储引擎下索引和数据存储是分离的，InnoDB索引和数据存储在一起。 
6. InnoDB存储引擎下索引的实现，(辅助索引)全部是依赖于主索引建立的(辅助索引中叶子结点存储的并不是数据的地址，还是主索引的值，因此，所有依赖于辅助索引的都是先根据辅助索引查到主索引，再根据主索引查数据的地址)。 
7. 由于InnoDB索引的特性，因此如果主索引不是自增的(id作主键)，那么每次插入新的数据，都很可能对B+Tree的主索引进行重整，影响性能。因此，尽量以自增id作为InnoDB的主索引。

## InnoDB一棵B+树能存多少行数据？为什么要用B+树？而不是其他树？

InnoDB一棵B+树可以存放多少行数据？这个问题的简单回答是：约2千万。为什么是这么多呢？因为这是可以算出来的，要搞清楚这个问题，我们先从InnoDB索引数据结构、数据组织方式说起。

我们都知道计算机在存储数据的时候，有最小存储单元，这就好比我们今天进行现金的流通最小单位是一毛。在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k，而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。

innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是16384（16k）的整数倍。

磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元。

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620154236.png)

在MySQL中我们的InnoDB页的大小默认是16k，当然也可以通过参数设置：

```mysql
mysql> show variables like 
'innodb_page_size';
+------------------+-------+
| Variable_name| Value|
+------------------+-------+
| innodb_page_size | 16384|
+------------------+-------+
1 row in set(0.00sec)
```

数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。

如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题，因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。所以人们想了一个办法，用B+树的方式组织这些数据。如图所示：

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620154344.png)

我们先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放3条记录，实际情况可以存放很多），除了存放数据的页以外，还有存放键值+指针的页，如图中page number=3的页，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成。当然它也是排好序的。这样的数据组织形式，我们称为索引组织表。现在来看下，要查找一条数据，怎么查？

如**select \* from user where id=5**;

这里id是主键,我们通过这棵B+树来查找，首先找到根页，你怎么知道user表的根页在哪呢？其实每张表的根页位置在表空间文件中是固定的，即page number=3的页（这点我们下文还会进一步证明），找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中，那么进一步去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录：

**| 5 | zhao2 | 27 |**

现在我们清楚了InnoDB中主键索引B+树是如何组织数据、查询数据的，我们总结一下：

1、InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。

2、索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；

### 那么回到我们开始的问题，通常一棵B+树可以存放多少行数据？

这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：**根节点指针数\*单个叶子节点记录行数**。

上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。

**那么现在我们需要计算出非叶子节点能存放多少指针？**

其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即**16384/14=1170**。那么可以算出一棵高度为2的B+树，能存放**1170\*16=18720**条这样的数据记录。

**根据同样的原理我们可以算出一个高度为3的B+树可以存放**：**1170\*1170\*16=21902400**条这样的记录。

所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。

### 怎么得到InnoDB主键索引B+树的高度？

上面我们通过推断得出B+树的高度通常是1-3，下面我们从另外一个侧面证明这个结论。在InnoDB的表空间文件中，约定**page number为3**的代表主键索引的根页，而在根页偏移量为**64**的地方存放了该B+树的page level。如果page level为1，树高为2，page level为2，则树高为3。即B+树的高度=page level+1；下面我们将从实际环境中尝试找到这个page level。

在实际操作之前，你可以通过InnoDB元数据表确认主键索引根页的page number为3，你也可以从《InnoDB存储引擎》这本书中得到确认。

```mysql
SELECT
b.name, a.name, index_id, type, a.space, a.PAGE_NO
FROM
information_schema.INNODB_SYS_INDEXES a,
information_schema.INNODB_SYS_TABLES b
WHERE
a.table_id = b.table_id AND a.space <> 0;
```

执行结果：

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620154405.png)

可以看出数据库dbt3下的customer表、lineitem表主键索引根页的page number均为3，而其他的二级索引page number为4。关于二级索引与主键索引的区别请参考MySQL相关书籍，本文不在此介绍。

**下面我们对数据库表空间文件做想相关的解析：**

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620154422.png)

因为主键索引B+树的根页在整个表空间文件中的第3个页开始，所以可以算出它在文件中的偏移量：**16384\*3=49152（16384为页大小）**。

另外根据《InnoDB存储引擎》中描述在根页的64偏移量位置前2个字节，保存了page level的值，因此我们想要的page level的值在整个文件中的偏移量为：**16384\*3+64=49152+64=49216**，前2个字节中。

**接下来我们用hexdump工具，查看表空间文件指定偏移量上的数据：**

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620154438.png)

**linetem表的page level为2，B+树高度为page level+1=3；****region表的page level为0，B+树高度为page level+1=1；****customer表的page level为2，B+树高度为page level+1=3；**

**这三张表的数据量如下：**

![](https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620154455.png)

## 小结

lineitem表的数据行数为600多万，B+树高度为3，customer表数据行数只有15万，B+树高度也为3。可以看出尽管数据量差异较大，这两个表树的高度都是3，换句话说这两个表通过索引查询效率并没有太大差异，因为都只需要做3次IO。那么如果有一张表行数是一千万，那么他的B+树高度依旧是3，查询效率仍然不会相差太大。

region表只有5行数据，当然他的B+树高度为1。

### 最后回顾一道面试题

有一道MySQL的面试题，为什么MySQL的索引要使用B+树而不是其它树形结构？比如B树？

现在这个问题的复杂版本可以参考本文；

**他的简单版本回答是：**

因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；

### 总结

本文从一个问题出发，逐步介绍了InnoDB索引组织表的原理、查询方式，并结合已有知识，回答该问题，结合实践来证明。当然为了表述简单易懂，文中忽略了一些细枝末节，比如一个页中不可能所有空间都用于存放数据，它还会存放一些少量的其他字段比如page level，index number等等，另外还有页的填充因子也导致一个页不可能全部用于保存数据。关于二级索引数据存取方式可以参考MySQL相关书籍，他的要点是结合主键索引进行回表查询。
[参考](https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452966459&idx=1&sn=91fd510de84bed68067bfcf94808f2ae&scene=21#wechat_redirect)
[参考](https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452966459&idx=1&sn=91fd510de84bed68067bfcf94808f2ae&scene=21#wechat_redirect)